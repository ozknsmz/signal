<!DOCTYPE html>
<html lang="en">

<head>

    <link rel="stylesheet" href="style.css">

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Video App</title>
</head>

<body>

    <div>
        <h3>Your Id: <span id="myId"></span></h3>
        <h3>Online Users (click to connect)</h3>
        <div id="users">

        </div>

        <section>
            <div>
                <form id="fileInfo">
                    <input type="file" id="fileInput" name="files" />
                </form>
                <button disabled id="sendFile">Send</button>
                <button disabled id="abortButton">Abort</button>
            </div>

            <div class="progress">
                <div class="label">Send progress: </div>
                <progress id="sendProgress" max="0" value="0"></progress>
            </div>

            <div class="progress">
                <div class="label">Receive progress: </div>
                <progress id="receiveProgress" max="0" value="0"></progress>
            </div>

            <div id="bitrate"></div>
            <a id="download"></a>
            <span id="status"></span>

        </section>
    </div>
    </div>
    <p id="status"></p>
    </div>

    <!-- Import socket.io script -->
    <script src="/socket.io/socket.io.js"></script>


    <script>

        let localConnection;
        let remoteConnection;
        let sendChannel;
        let receiveChannel;
        let fileReader;
        const bitrateDiv = document.querySelector("div#bitrate");
        const fileInput = document.querySelector("input#fileInput");
        const abortButton = document.querySelector("button#abortButton");
        const downloadAnchor = document.querySelector("a#download");
        const sendProgress = document.querySelector("progress#sendProgress");
        const receiveProgress = document.querySelector("progress#receiveProgress");
        const statusMessage = document.querySelector("span#status");
        const sendFileButton = document.querySelector("button#sendFile");

        let receiveBuffer = [];
        let receivedSize = 0;
        let fileSizeInfoReceived;
        let fileNameRecieved;

        let bytesPrev = 0;
        let timestampPrev = 0;
        let timestampStart;
        let statsInterval = null;
        let bitrateMax = 0;
        sendFileButton.addEventListener("click", () => createCall());
        fileInput.addEventListener("change", handleFileInputChange, false);

        abortButton.addEventListener("click", () => {
            if (fileReader && fileReader.readyState === 1) {
                console.log("Abort read!");
                fileReader.abort();
            }
        });
        async function handleFileInputChange() {
            const file = fileInput.files[0];
            if (!file) {
                console.log("No file chosen");
            } else {
                sendFileButton.disabled = false;
            }
        }

        const socket = io();
        const peer = new RTCPeerConnection({
            iceServers: [
                {
                    urls: "stun:stun.stunprotocol.org"
                }
            ]
        });

        const createCall = async (to) => {
            const status = document.getElementById('status');
            status.innerText = `Calling ${to}`;
            console.log(to);
            console.log(fileInput.files);

            const localOffer = await peer.createOffer();
            await peer.setLocalDescription(new RTCSessionDescription(localOffer));
            sendChannel = peer.createDataChannel("sendDataChannel");
            sendChannel.binaryType = "arraybuffer";

            sendChannel.addEventListener("open", onSendChannelStateChange);
            console.log("Connection OPENED!");
            sendChannel.addEventListener("close", onSendChannelStateChange);
            sendChannel.addEventListener("error", onError);

            socket.emit('outgoing:call', { fromOffer: localOffer, to });
        }



        socket.on('users:joined', (id) => {
            const usersDiv = document.getElementById('users');
            const btn = document.createElement('button');
            const textNode = document.createTextNode(id);

            btn.id = id;

            btn.setAttribute('onclick', `createCall('${id}')`);
            btn.appendChild(textNode);
            usersDiv.appendChild(btn);
        });


        socket.on('incomming:answere', async data => {
            const status = document.getElementById('status');
            status.innerText = 'incomming:answere';

            const { offer } = data;
            await peer.setRemoteDescription(new RTCSessionDescription(offer));

        });

        socket.on('user:disconnect', id => {
            document.getElementById(id).remove()
        })

        socket.on('incomming:call', async data => {
            const status = document.getElementById('status');
            status.innerText = 'incomming:call';

            const { from, offer } = data;

            await peer.setRemoteDescription(new RTCSessionDescription(offer));
            const answereOffer = await peer.createAnswer();
            await peer.setLocalDescription(new RTCSessionDescription(answereOffer));
            await peer.addEventListener("datachannel", receiveChannelCallback);

            socket.emit('call:accepted', { answere: answereOffer, to: from });
        })

        function receiveChannelCallback(event) {
            console.log("Receive Channel Callback");
            receiveChannel = event.channel;
            receiveChannel.binaryType = "arraybuffer";
            receiveChannel.onmessage = onReceiveMessageCallback;
            receiveChannel.onopen = onReceiveChannelStateChange;
            receiveChannel.onclose = onReceiveChannelStateChange;
            console.log("Connection OPENED!");

            receivedSize = 0;
            bitrateMax = 0;
            downloadAnchor.textContent = "";
            downloadAnchor.removeAttribute("download");
            console.log(downloadAnchor.href);
            if (downloadAnchor.href) {
                URL.revokeObjectURL(downloadAnchor.href);
                downloadAnchor.removeAttribute("href");
            }
        }

        const getAndUpdateUsers = async () => {
            const usersDiv = document.getElementById('users');
            usersDiv.innerHTML = ''

            const response = await fetch('/users', { method: 'GET' });
            const jsonResponse = await response.json();

            console.log(jsonResponse)

            jsonResponse.forEach(user => {
                const btn = document.createElement('button');
                const textNode = document.createTextNode(user[0]);

                btn.id = user[0];

                btn.setAttribute('onclick', `createCall('${user[0]}')`);
                btn.appendChild(textNode);
                usersDiv.appendChild(btn);
            });
        }

        socket.on('hello', ({ id }) => document.getElementById('myId').innerText = id)


        // yeni kullanıcı eklendiğinde sayfada kullanıcı id gösterir.
        window.addEventListener('load', getAndUpdateUsers);
        // window.addEventListener('load', getUserMedia);

        function onSendChannelStateChange() {
            if (sendChannel) {
                const { readyState } = sendChannel;
                console.log(`Send channel state is: ${readyState}`);
                if (readyState === "open") {
                    sendData();
                }
            }
        }

        function onError(error) {
            if (sendChannel) {
                console.error("Error in sendChannel:", error);
                return;
            }
            console.log("Error in sendChannel which is already closed:", error);
        }

        function sendData() {
            const file = fileInput.files[0];
            console.log(file)

            console.log(
                `File is ${[file.name, file.size, file.type, file.lastModified].join(" ")}`
            );

            // Handle 0 size files.
            statusMessage.textContent = "";
            downloadAnchor.textContent = "";

            sendProgress.max = file.size;
            receiveProgress.max = file.size;
            const chunkSize = 16384;
            fileReader = new FileReader();
            let offset = 0;
            fileReader.addEventListener("error", (error) =>
                console.error("Error reading file:", error)
            );
            fileReader.addEventListener("abort", (event) =>
                console.log("File reading aborted:", event)
            );
            fileReader.addEventListener("load", (e) => {
                console.log("FileRead.onload ", e);
                sendChannel.send(e.target.result);
                offset += e.target.result.byteLength;
                sendProgress.value = offset;
                if (offset < file.size) {
                    readSlice(offset);
                }
            });
            const readSlice = (o) => {
                console.log("readSlice ", o);
                const slice = file.slice(offset, o + chunkSize);
                fileReader.readAsArrayBuffer(slice);
            };
            readSlice(0);
        }


        function onReceiveMessageCallback(event) {
            console.log(event.data)
            console.log(`Received Message ${event.data.byteLength}`);
            receiveBuffer.push(event.data);
            receivedSize += event.data.byteLength;
            receiveProgress.value = receivedSize;

            console.log(receivedSize);
            console.log(fileSizeInfoReceived);

            if (receivedSize === fileSizeInfoReceived) {
                console.log("here");
                const received = new Blob(receiveBuffer);
                receiveBuffer = [];

                downloadAnchor.href = URL.createObjectURL(received);
                downloadAnchor.download = fileSizeInfoReceived;
                downloadAnchor.textContent = `Click to download '${fileNameRecieved}' (${fileSizeInfoReceived} bytes)`;
                downloadAnchor.style.display = "block";

                const bitrate = Math.round(
                    (receivedSize * 8) / (new Date().getTime() - timestampStart)
                );
                bitrateDiv.innerHTML = `<strong>Average Bitrate:</strong> ${bitrate} kbits/sec (max: ${bitrateMax} kbits/sec)`;

                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                }

                closeDataChannels();
            }
        }
        function onSendChannelStateChange() {
            if (sendChannel) {
                const { readyState } = sendChannel;
                console.log(`Send channel state is: ${readyState}`);
                if (readyState === "open") {
                    sendData();
                }
            }
        }

        async function onReceiveChannelStateChange() {
            if (receiveChannel) {
                const readyState = receiveChannel.readyState;
                console.log(`Receive channel state is: ${readyState}`);
                if (readyState === "open") {
                    timestampStart = new Date().getTime();
                    timestampPrev = timestampStart;
                    statsInterval = setInterval(displayStats, 500);
                    await displayStats();
                }
            }
        }

        async function displayStats() {
            if (remoteConnection && remoteConnection.iceConnectionState === "connected") {
                const stats = await remoteConnection.getStats();
                let activeCandidatePair;
                stats.forEach((report) => {
                    if (report.type === "transport") {
                        activeCandidatePair = stats.get(report.selectedCandidatePairId);
                    }
                });
                if (activeCandidatePair) {
                    if (timestampPrev === activeCandidatePair.timestamp) {
                        return;
                    }
                    // calculate current bitrate
                    const bytesNow = activeCandidatePair.bytesReceived;
                    const bitrate = Math.round(
                        ((bytesNow - bytesPrev) * 8) /
                        (activeCandidatePair.timestamp - timestampPrev)
                    );
                    bitrateDiv.innerHTML = `<strong>Current Bitrate:</strong> ${bitrate} kbits/sec`;
                    timestampPrev = activeCandidatePair.timestamp;
                    bytesPrev = bytesNow;
                    if (bitrate > bitrateMax) {
                        bitrateMax = bitrate;
                    }
                }
            }
        }



    </script>
</body>

</html>